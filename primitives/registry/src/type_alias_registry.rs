//! Type Alias Registry â€” semantic database for type canonicalization mappings.
//!
//! The TypeAliasRegistry provides a unified way to store, retrieve, and query
//! type canonicalization mappings generated by the TypePromotionPass. It allows
//! downstream passes to resolve type aliases to their canonical forms and query
//! the semantic relationships between types.

use std::collections::HashMap;
use std::fs;
use std::path::Path;

use serde::{Deserialize, Serialize};

/// A registry that stores and manages type canonicalization mappings.
///
/// The registry provides a unified way to store, retrieve, and query
/// type canonicalization mappings generated by the TypePromotionPass. It maintains
/// mappings from type aliases to their canonical forms and provides utilities
/// for downstream passes to resolve type references consistently.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct TypeAliasRegistry {
    /// Map from type alias to canonical type name
    alias_to_canonical: HashMap<String, String>,
}

impl TypeAliasRegistry {
    /// Create a new type alias registry from a mapping.
    ///
    /// # Arguments
    /// * `alias_to_canonical` - HashMap from type alias to canonical type name
    pub fn new(alias_to_canonical: HashMap<String, String>) -> Self { Self { alias_to_canonical } }

    /// Load a type alias registry from a JSON file.
    ///
    /// # Arguments
    /// * `path` - Path to the JSON file containing the type alias mappings
    ///
    /// # Returns
    /// * `Ok(TypeAliasRegistry)` - Successfully loaded registry
    /// * `Err` - If file cannot be read or parsed
    pub fn load_from_file<P: AsRef<Path>>(
        path: P,
    ) -> Result<Self, Box<dyn std::error::Error + Send + Sync>> {
        let content = fs::read_to_string(path)
            .map_err(|e| Box::new(e) as Box<dyn std::error::Error + Send + Sync>)?;
        let alias_to_canonical: HashMap<String, String> = serde_json::from_str(&content)
            .map_err(|e| Box::new(e) as Box<dyn std::error::Error + Send + Sync>)?;
        Ok(Self { alias_to_canonical })
    }

    /// Resolve a type name to its canonical form.
    ///
    /// If the type is an alias, returns the canonical type name.
    /// If the type is already canonical or not found, returns the original name.
    ///
    /// # Arguments
    /// * `type_name` - The type name to resolve
    ///
    /// # Returns
    /// The canonical type name
    pub fn resolve<'a>(&'a self, type_name: &'a str) -> &'a str {
        self.alias_to_canonical.get(type_name).map(|s| s.as_str()).unwrap_or(type_name)
    }

    /// Check if a type name is an alias (has a canonical form).
    ///
    /// # Arguments
    /// * `type_name` - The type name to check
    ///
    /// # Returns
    /// `true` if the type is an alias, `false` otherwise
    pub fn is_alias(&self, type_name: &str) -> bool {
        self.alias_to_canonical.contains_key(type_name)
    }

    /// Get the number of type mappings in the registry.
    ///
    /// # Returns
    /// Number of type alias mappings
    pub fn len(&self) -> usize { self.alias_to_canonical.len() }

    /// Check if the registry is empty.
    ///
    /// # Returns
    /// `true` if no mappings exist, `false` otherwise
    pub fn is_empty(&self) -> bool { self.alias_to_canonical.is_empty() }

    /// Get the canonical type for a specific alias.
    ///
    /// # Arguments
    /// * `alias` - The type alias to look up
    ///
    /// # Returns
    /// `Some(canonical_type)` if the alias exists, `None` otherwise
    pub fn get_canonical(&self, alias: &str) -> Option<&str> {
        self.alias_to_canonical.get(alias).map(|s| s.as_str())
    }

    /// Validate that all provided type names exist in the registry.
    ///
    /// This method checks whether all the provided type names are either
    /// aliases (have canonical forms) or canonical types themselves.
    /// This is useful for catching unknown types during development or testing.
    ///
    /// # Arguments
    /// * `type_names` - Iterator of type names to validate
    ///
    /// # Returns
    /// * `Ok(())` - All types are known (either aliases or canonical)
    /// * `Err(unknown_types)` - List of unknown type names that don't exist in the registry
    pub fn validate_types<I>(&self, type_names: I) -> Result<(), Vec<String>>
    where
        I: IntoIterator<Item = String>,
    {
        let unknown: Vec<String> = type_names
            .into_iter()
            .filter(|name| {
                !self.alias_to_canonical.contains_key(name.as_str())
                    && !self.is_canonical_type(name)
            })
            .collect();

        if unknown.is_empty() {
            Ok(())
        } else {
            Err(unknown)
        }
    }

    /// Check if a type name is a canonical type (referenced by any alias).
    ///
    /// # Arguments
    /// * `type_name` - The type name to check
    ///
    /// # Returns
    /// `true` if the type is referenced as a canonical type by any alias, `false` otherwise
    pub fn is_canonical_type(&self, type_name: &str) -> bool {
        self.alias_to_canonical.values().any(|canonical| canonical == type_name)
    }

    /// Insert or update a type alias mapping.
    ///
    /// # Arguments
    /// * `alias` - The type alias to map
    /// * `canonical` - The canonical type name
    pub fn insert(&mut self, alias: String, canonical: String) {
        self.alias_to_canonical.insert(alias, canonical);
    }
}

/// Trait defining the read-only interface to the Type Alias Registry.
///
/// This trait provides a clean abstraction for accessing type alias registry
/// data without allowing modifications. It's used by compiler passes and
/// higher-level orchestrators to query type canonicalization mappings.
pub trait TypeAliasRegistryReader {
    /// Resolve a type name to its canonical form.
    fn resolve_type<'a>(&'a self, type_name: &'a str) -> &'a str;

    /// Check if a type name is an alias.
    fn is_type_alias(&self, type_name: &str) -> bool;

    /// Get the number of type mappings.
    fn type_mapping_count(&self) -> usize;

    /// Validate that all provided type names exist in the registry.
    fn validate_types<I>(&self, type_names: I) -> Result<(), Vec<String>>
    where
        I: IntoIterator<Item = String>;

    /// Check if a type name is a canonical type.
    fn is_canonical_type(&self, type_name: &str) -> bool;
}

/// Implement the trait for the internal TypeAliasRegistry struct.
impl TypeAliasRegistryReader for TypeAliasRegistry {
    fn resolve_type<'a>(&'a self, type_name: &'a str) -> &'a str { self.resolve(type_name) }

    fn is_type_alias(&self, type_name: &str) -> bool { self.is_alias(type_name) }

    fn type_mapping_count(&self) -> usize { self.len() }

    fn validate_types<I>(&self, type_names: I) -> Result<(), Vec<String>>
    where
        I: IntoIterator<Item = String>,
    {
        self.validate_types(type_names)
    }

    fn is_canonical_type(&self, type_name: &str) -> bool { self.is_canonical_type(type_name) }
}
