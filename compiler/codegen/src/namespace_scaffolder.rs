//! # ModuleGenerator – automated namespace scaffolding
//!
//! This crate contains **`ModuleGenerator`**, a tiny utility whose sole job is to
//! _write the `mod.rs` glue files you would otherwise maintain by hand_.
//!
//! Given a list of Bitcoin Core RPC schema versions—e.g. `["latest"]`—
//! and an output directory that already holds code‑generated sources like
//!
//! ```text
//! responses/<version>_types/*.rs
//! ```
//!
//! the generator creates **all** of the Rust namespaces so that downstream code
//! can simply use `generated::responses::*` (re‑exports latest_types…).
//!
//! Concretely it writes:
//!
//! 1. `responses/<version>_types/mod.rs` – declares the per‑version type modules
//! 2. `responses/mod.rs` – re‑export every version so callers
//! 1. `client/<version>/mod.rs` – declares the per‑version RPC client modules
//! 2. `responses/<version>_types/mod.rs` – declares the per‑version type modules
//! 3. `client/mod.rs` **and** `responses/mod.rs` – re‑export every version so callers
//!    don’t need to spell them out individually
//!
//! In short, **`ModuleGenerator` is a “namespace builder”**: it fabricates the
//! entire module hierarchy that stitches together code‑generated type definitions,
//! type definitions, eliminating the need to touch `mod.rs` files ever again.

use std::path::{Path, PathBuf};
use std::{fs, io};

use types::ProtocolVersion;

/// **`ModuleGenerator`**
/// Builds the *module scaffolding* that glues all the code‑generated files
/// together – essentially every `mod.rs` you’d otherwise write by hand.
///
/// * `versions` is a list like `["latest"]` that you want to
///   appear as sub‑modules (one folder per RPC‑schema version).
/// * `out_dir` is the root folder that already contains `client/`,
///   `types/`, etc. (e.g. `client/src/generated`).
pub struct ModuleGenerator {
    versions: Vec<ProtocolVersion>,
    out_dir: PathBuf,
}

impl ModuleGenerator {
    /// Create a new generator for the given `versions` and output directory.
    pub fn new(versions: Vec<ProtocolVersion>, out_dir: PathBuf) -> Self {
        Self { versions, out_dir }
    }

    /// Convenience orchestrator – call this once and you'll get **all**
    /// `mod.rs` files written:
    /// 1. `responses/<version>_responses/mod.rs`
    /// 2. top‑level re‑export files (`responses/mod.rs`)
    pub fn generate_all(&self) -> io::Result<()> {
        self.generate_responses_mod_rs()?;
        self.generate_top_level_responses_mod()?;
        Ok(())
    }

    /// Writes _one_ `mod.rs` that lives in
    /// `…/responses/mod.rs` and declares `pub mod latest_responses; …`.
    pub fn generate_responses_mod_rs(&self) -> io::Result<()> {
        generate_versioned_mod_rs(
            &self.versions,
            &self.out_dir,
            "responses",
            "pub mod {}_responses;",
        )
    }

    /// Creates the top‑level responses module file that declares `pub mod` for each version
    /// and then `pub use` every version so downstream crates can do `use generated::responses::*`.
    fn generate_top_level_responses_mod(&self) -> io::Result<()> {
        use std::fmt::Write;

        let mut types_mod_rs = String::new();
        writeln!(types_mod_rs, "//! Bitcoin Core RPC response types.").map_err(io::Error::other)?;
        writeln!(types_mod_rs, "//!").map_err(io::Error::other)?;
        writeln!(
            types_mod_rs,
            "//! This module contains response types for Bitcoin Core RPC methods."
        )
        .map_err(io::Error::other)?;
        writeln!(types_mod_rs, "//! Auto-generated - do not edit this file manually.")
            .map_err(io::Error::other)?;
        writeln!(types_mod_rs).map_err(io::Error::other)?;

        for version in &self.versions {
            let module_name = version
                .as_module_name()
                .map_err(|e| io::Error::new(io::ErrorKind::InvalidInput, e))?;
            writeln!(types_mod_rs, "pub mod {}_responses;", module_name)
                .map_err(io::Error::other)?;
        }
        writeln!(types_mod_rs).map_err(io::Error::other)?;

        for version in &self.versions {
            let module_name = version
                .as_module_name()
                .map_err(|e| io::Error::new(io::ErrorKind::InvalidInput, e))?;
            writeln!(types_mod_rs, "pub use self::{}_responses::*;", module_name)
                .map_err(io::Error::other)?;
        }

        let types_mod_path = self.out_dir.join("responses").join("mod.rs");
        fs::create_dir_all(types_mod_path.parent().expect("Path should have parent directory"))?;
        fs::write(&types_mod_path, types_mod_rs)?;
        Ok(())
    }
}

/// Helper function to generate a mod.rs file declaring versioned modules.
fn generate_versioned_mod_rs(
    versions: &[ProtocolVersion],
    out_dir: &Path,
    subdir: &str,
    mod_template: &str,
) -> io::Result<()> {
    use std::fmt::Write;

    let mod_rs_content = versions.iter().fold(String::new(), |mut output, version| {
        if let Ok(module_name) = version.as_module_name() {
            let _ = writeln!(output, "{}", mod_template.replace("{}", &module_name));
        }
        output
    });

    let mod_path = out_dir.join(subdir).join("mod.rs");
    fs::create_dir_all(mod_path.parent().expect("Path should have parent directory"))?;
    fs::write(&mod_path, mod_rs_content)?;
    Ok(())
}
